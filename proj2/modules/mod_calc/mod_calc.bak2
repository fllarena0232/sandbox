#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kallsyms.h>
#include <linux/syscalls.h>

unsigned long *sys_call_table;
asmlinkage long (*original_sys_calc)(int, int, char, int*);

// Replacement for sys_calc that always does modulo
asmlinkage long mod_sys_calc(int param1, int param2, char operation, int* result) {
    int temp_result;

    if (param2 == 0) {
        return -1; // prevent division by zero
    }

    temp_result = param1 % param2;

    if (copy_to_user(result, &temp_result, sizeof(int))) {
        return -1;
    }

    return 0;
}

static int __init mod_calc_init(void) {
    sys_call_table = (unsigned long*) kallsyms_lookup_name("sys_call_table");
    if (!sys_call_table) {
        printk(KERN_ERR "Failed to find sys_call_table\n");
        return -1;
    }

    // Save original sys_calc and replace with mod_sys_calc
    write_cr0(read_cr0() & (~ 0x10000));  // Disable write protection
    original_sys_calc = (void*)sys_call_table[397];
    sys_call_table[397] = (unsigned long)mod_sys_calc;
    write_cr0(read_cr0() | 0x10000);  // Re-enable write protection

    printk(KERN_INFO "mod_calc loaded: sys_calc is now mod\n");
    return 0;
}

static void __exit mod_calc_exit(void) {
    // Restore original sys_calc
    write_cr0(read_cr0() & (~ 0x10000));  // Disable write protection
    sys_call_table[397] = (unsigned long)original_sys_calc;
    write_cr0(read_cr0() | 0x10000);  // Re-enable write protection

    printk(KERN_INFO "mod_calc unloaded: sys_calc restored\n");
}

module_init(mod_calc_init);
module_exit(mod_calc_exit);

MODULE_LICENSE("GPL");
