#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/syscalls.h>
#include <linux/uaccess.h>
#include <linux/kallsyms.h>
#include <asm/paravirt.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Federico Llarena");
MODULE_DESCRIPTION("LKM to modify calc system call to always perform modulo");

unsigned long **sys_call_table;

// Pointer to the original calc system call.
asmlinkage long (*calc)(int, int, char,int __user*);

// New calc system call that always performs modulo.
asmlinkage long new_calc(int a, int b, char operation, int __user *result) {
    printk(KERN_INFO "Intercepted calc system call: Performing %d %% %d\n", a, b);
    if (b == 0) {
        printk(KERN_WARNING "Attempt to divide by zero!\n");
        return -EINVAL; // Return error for divide by zero.
    }
    return a % b; // Always return modulo operation.
}

// Find the system call table address.
unsigned long **find_sys_call_table(void) {
    unsigned long offset;
    unsigned long **sct;

    for (offset = PAGE_OFFSET; offset < ULLONG_MAX; offset += sizeof(void *)) {
        sct = (unsigned long **)offset;

        if (sct[__NR_close] == (unsigned long *)sys_close)
            return sct;
    }
    return NULL;
}

// Disable write protection on the page containing the system call table.
//static void disable_wp(void) {
//    write_cr0(read_cr0() & (~0x10000));
//}

// Re-enable write protection on the page containing the system call table.
//static void enable_wp(void) {
//    write_cr0(read_cr0() | 0x10000);
//}

// Module initialization.
static int __init lkm_init(void) {
    // Find the system call table.
    sys_call_table = find_sys_call_table();

    if (!sys_call_table) {
        printk(KERN_ERR "Couldn't find the system call table\n");
        return -1;
    }

    // Save the original calc system call.
    calc = (void *)sys_call_table[__NR_sys_calc];

    // Disable write protection, replace calc system call with new_calc.
    disable_wp();
    sys_call_table[__NR_sys_calc] = (unsigned long *)new_calc;
    enable_wp();

    printk(KERN_INFO "Loaded LKM: calc system call is now replaced with modulo operation\n");
    return 0;
}

// Module cleanup.
static void __exit lkm_exit(void) {
    // Restore the original calc system call.
    if (sys_call_table) {
        disable_wp();
        sys_call_table[__NR_sys_calc] = (unsigned long *)sys_calc;
        enable_wp();
    }

    printk(KERN_INFO "Unloaded LKM: calc system call restored\n");
}

module_init(lkm_init);
module_exit(lkm_exit);
